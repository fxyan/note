# http权威指南
"""
响应header
content-type :其实是服务器给不同的web资源的一种资源种类的标记，通过这个标记服务器来确定资源的种类，
                并且按照对应的标准来处理
uri 统一资源标识符
url 统一资源定位符

URL一般情况是这样的  方案://服务器位置(IP/网址)/路径
方案名称大小写无所谓
相对URL如果已经在一个页面的时候可以使用相对URL和基础URL拼成新的访问URL  例如 ./2233.html这个就是基础url的一个
拓展省略了前面的东西

转义
    对于某些不安全的字符集在URL中出现的时候需要进行转义，以方便同样的URL在所有的协议和网关中都能够正常运行
    而不至于对几个特殊含义的字符进行处理

request
    GET /hello HTTP/1.1 \r\n
    Host: www.liubai.com\r\n
    \r\n
    body

response
    HTTP/1.1 200 OK \r\n
    Content-type: text/plain\r\n
    Content-length: 19\r\n
    \r\n
    body

一条连接的访问顺序
    首先输入一个URL，DNS服务为你解析域名，转换成对应的ip地址，得到端口号，将端口号和ip地址绑定进行tcp连接
    发送请求报文，接收响应报文关闭连接

HTTP事务延迟 与解决方法
    首先是根据URL来分析出ip和端口号 DNS需要时间
    得到上面的数据之后需要建立TCP连接
    连接建立完成之后会传输HTTP请求并且处理请求
    处理完请求之后传输回去响应

    为了解决上面的问题，以打开一个页面需要加载4幅图片为例 有下面几种解决方案
    并行连接
        打开四个TCP连接用来加载四幅图片
        缺点是这样不一定(也可能加快速速)能够加快连接的速度，因为不管你打开几个连接最后还是
        一起去竞争固定的带宽如果带宽过小，那么网速快的连接就会得到更多的资源，而且建立很多TCP连接需要时间，实际打开
        的链接数量也有限
    持久连接
        Connection: keep-alive 请求发送这个选项如果服务器支持keep-alive的话那么就返回一个Connection: keep-alive
        不支持的话就不返回 HTTP1.1是默认开启keep-alive的 Connection: close 可以关闭
        作用 在网页的资源没有被加载完之前不关闭TCP连接

HTTP服务器实现基本任务的步骤
    首先查看是否已经有了一个开启的链接，如果没有就打开一个新的TCP连接
    接收请求报文，这里包含了各种服务器类型，什么io复用啥的
    处理请求报文
    访问URL对应的资源，可以是静态文件或者是html或者是动态处理的东西
    构建响应，处理对应的函数
    发送响应
    记录日志

代理
    代理使用的是同一种协议，对于一个HTTP代理来说要求能够同时收发请求响应
    代理可以过滤请求，增加功能，缓存，反向代理

缓存
    个人理解
        有的时候访问者会访问一个重复的页面或者重复的资源多次，这个时候如果没有缓存的话就需要多次的进行同样文件
        的传输，如果有一个缓存能够存储到常用的网站，那么就会大大减少耗费的时间
    常见作用
        减少冗余传输
        带宽瓶颈
            因为在本地网络的带宽一般是比远程网络的带宽要宽得多，如果提前缓存那么下载速度可以得到质的提升
        瞬间阻塞
            在一个时间段出现了一些爆炸新闻，导致访问量爆炸增长，超出了服务器能够接受的范围这样会使服务器崩溃，提前缓存
            能够有效缓解这种问题
        距离时延
            因为光速本来就是一个面对长距离容易出现时延的东西，所以如果服务器距离本地太远，会导致出现距离时延
        缓存命中与未命中
            能够找到缓存就是命中了，没找到就是没命中
    缓存新鲜度
        在一般情况下使用缓存的时候，缓存都会向服务器发送一个请求来判断缓存是否过期(因为缓存的时候和现在有了一段时间
        可能其中网页什么的出现了更新和缓存中的内容不相同了)这个时候缓存添加一个头部 If-Modified-Since: 日期
        如果没有更新说明缓存是可以正常使用的那么服务器返回一个304，如果需要更新缓存的话那么就按照缓存未命中来进行
        通过文档首部的header来记录文档的过期时间
            Expires: 日期
            Cache-Control: max-age 时间
        这两个header都可以记录过期时间，一旦超过过期时间那么再从缓存中获取该文件的时候就应该想服务器询问文件是否被
        跟新或者更改，如果没有就更新过期时间，如果有就从新缓存
        相比上面的If-Modified-Since  , If-No-Match可以判断版本号来进行更新
        当然如果你需要访问次数的话你也可以设置缓存，让每次的访问都去访问一次服务器，但是不返回实体

    缓存层次化
        有层次结构  1 2 3 级缓存依次向上越来越大离用户越来越远，1级找不到去父缓存2级找以此类推
        网络结构    动态的选择去哪个地方寻找被缓存的信息，可能去各种缓存的地点，也可能去原始服务器
    缓存的步骤
        接收  接收发来的HTTP请求
        解析  解析请求的内容
        查询  查询缓存中是否存在一个你需要的文件，如果没有的话就向服务器请求
        新鲜度检测   判断缓存是否过期，过期的话就向服务器请求
        构造响应    通过缓存的主题和新的头部来形成新的响应
        发送     发送请求
        记录日志    在本地找个地方记录日志

HTTP重要程序
代理  客户端和浏览器之间的HTTP中间实体
    大致上来说就是分成正反向代理，一般就是在浏览器和服务器之间接收请求(响应)的东西，可能会进行一些处理
    反向代理就是接收所有的客户端发送的数据，然后在分发给服务器
网关  连接其他应用程序的特殊web服务器，一般用来将HTTP协议转换成另外的协议
隧道  对HTTP报文进行盲转发的的代理
缓存  HTTP页面的仓库，使常用的副本保存在离客户端更近的地方
    大概就是在一个访问地点很快的地方保留了经常访问的东西的副本，这样的情况下再次访问相同的页面就无需访问远程服务器了
    直接从缓存中访问，加快浏览速度
Agent代理 自动发起HTTP请求的半智能web浏览器
"""

# http头
"""
GET: 请求资源 从服务器向客户端发送资源
    请求服务器的一个资源，如果是一个html文本，就返回整个html，如果是一个程序之类的就返回程序运行的结果
POST: 传输实体  将客户端数据发送到一个服务器网关应用程序
    一般都是发送一些东西到服务器，让服务器进行操作比如表单之类的
HEAD: 获取报文首部(header) 作用 在不获取资源的情况下判断资源类型，查看资源是否存在，通过查看首部确定资源是否被修改
PUT: 上传文件,修改服务器内的文件，因为可以进行修改所以需一般需要验证
这里POST用来向服务器发送数据 PUT用来向服务器中文件来存储数据
PATCH: 对资源进行部分修改
DELETE: 删除资源
OPTIONS: 查询指定url支持的HTTP头方法
CONNECT: 要求在与代理服务器通信时建立隧道
TRACE: 追踪路径
POST PUT包含主体，其余的都不包含
"""
# 状态码
"""
100 表示到目前为止都很正常

200 成功
204 请求成功处理但是没有可以返回的数据，主要用于刷新，因为不需要返回新的数据
202 请求已被接受但是没有处理
206 请求了一部分的数据成功

301 永久重定向
302 临时性重定向
303 发送完POST请求重定向一个GET请求
304 不满足一些条件可能会出现的情况
307 临时重定向

400 请求报文中出现语法错误
401 发送的请求需要身份验证 如果上次请求是验证那么就说明用户的认证失败
405 有URL不支持的方法
403 请求被拒绝
404 根本没有这个东西

500 服务器出现了问题
503 服务器超负载或者正在维护， 无法支持的版本
"""

# 一些头部信息
"""
通用首部
    Date  日期
    Connection 与请求 响应 连接之间有关系的选项
请求首部
    Host: 服务器的主机和端口号
    Referer: 访问该页面的网址
    User-Agent: 发起请求的应用名称
    Accept 告诉服务器能发送什么媒体类型
    Accept-Charset 告诉服务器能可以发送的字符集
    Accept-Language 告诉服务器可以发送的语言
    Accept-Encoding  告诉服务器可以发送的编码方式
响应首部
    Age 响应持续时间
    Server 服务器应用软件的名称和版本
    Accept-Range 对于此资源来说服务器可以接受的范围类型
实体首部
拓展首部
Connection: keep-alive
用于范围接收
Range: bytes=5001-10000
请求
表示客户端这边可以接收的格式比如html
Accept:
表示请求的url的值  可以防止出现跨站脚本攻击
Referer
"""

# cookie session
"""
cookie
服务器在响应的时候会带上
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: wang=345
浏览器在接收到这种响应的时候下次的请求就会带上cookie
GET /code.html HTTP/1.1
Host: www.codelink.net
Cookie: wang=345
cookie 有两种状态
    一种是等浏览器关闭cookie自动清空
    另一种是设计过期时间
    
cookie分为两种
    会话cookie
        会话cookie属于临时cookie，记录临时访问的各种属性，当用户关闭浏览器的时候就会被删除
    持久cookie    
        记录在硬盘上，关机或者关闭浏览器也不会删除，一般用来对周期访问的网站进行存储
    因为有了cookie那么你访问的页面可能是私有的，所以一般来说服务器要对这种页面进行处理来确定是否可以缓存
Session
其实就是加密的cookie使用session来代替cookie可以防止敏感信息泄露

cookie只能储存ASCll码 Session可以储存所有类型的数据
可以将cookie进行加密到服务器进行解密
所有的session都用服务器来进行储存的话对服务器是一个比较大的开销
"""

# 服务器知识
"""
缓存
用来减少服务器的压力，也能让让用户获取信息的更加快速减少获取资源的延迟
使用代理服务器或者浏览器进行缓存

虚拟主机
一台服务器可以挂载多个域名，可以看成是多台服务器

代理
正向代理
    服务器不知道是谁在访问，客户端的请求全部由代理服务器来进行
反向代理
    客户端换在进行访问的时候不直接访问服务器，先访问负载均衡服务器，然后再由负载均衡服务器转发到空闲的
    服务器，空闲服务器将处理返回给负载均衡服务器，然后通过负载均衡服务器传回响应给客户端
"""

# HTTPS
"""
摘要认证
    进行了比较好的修改 永远不会以明文在网络中传输密码 可以防止对报文的篡改
    这个摘要认证的主要优点就是不会以明文的方式传输密码，相反的会传输一个摘要，服务器得到摘要后来和已记录的密码进行
摘要认证的简单描述过程
    首先客户端希望访问一个文档
    服务器发现这个文档是被密码保护的，返回了一个响应不对直接返回文档需要验证
    浏览器生成一个摘要发送个服务器证明自己是知道密码的
    服务器得到摘要然后将自身保存的密码进行摘要，如果有相同的那么说明就是这个文档，然后返回相应的文档
HTTPS
    就是在HTTP协议下面添加一个SSL 或者 TSL这样的安全层

加密算法窥伺
    密码 对文本编码是偷窥者无法识别的算法
    密匙 改变密码行为的数字化参数
    对称密匙加密系统 编/解码使用相同密匙的算法
    不对称密匙加密系统 编/解码使用不相同密匙的算法
    公开密匙加密系统 一种使百万计算机便捷发送机密报文的系统(对报文进行编码的密匙是公开的，但是对报文解码的密匙是私有
                    的，每个人都能找到对应主机的公开密匙)
    数字签名 用来验证报文未被伪造或篡改的校验和(是一个被加密过的校验和)
        首先将非定长的报文通过摘要算法(哈希算法)形成摘要，然后将摘要通过自身的私匙进行加密
        将摘要和报文一同发送过去
        接收端收到文件后，如果想测试这文件是否是安全的，就将摘要通过发送者的公匙进行解码(这里注意发送者的公匙是通过
                                                                                        数字证书发送过去的)          
        然后将报文进行摘要，如果两个完全相等的话就说明并没有被篡改
    数字证书 由一个可信任的机构验证和签发的识别信息
        数字证书携带数字签名和发送方的公开密匙证书发布者与过期时间
HTTPS
    首先HTTPS会从443端口进行连接，当你打开一个HTTPS的网页在建立三次握手的时候就会初始化TCP上层的安全层SSL，
    两端互相传输参数，在握手结束建立连接的时候安全层也被初始化完毕
    SSL握手
        在发送加密报文之前要先进行SSL握手
            交换协议版本号
            选择一个两端都了解的密码
            对两端的身份进行验证
            生成临时的会话密匙以便加密信道
        例子
            客户端向服务器发送可供选择的密码并且请求证书
            服务器返回一个被选中的密码和证书
            客户端发送保密信息，客户端服务器生成密匙
            客户端和服务器相互告知开始加密


是一个加密算法
首先将你的私匙和数字签名通过
首先要信任一个服务器，由服务器将一个服务器的私匙发送给你，然后你将你自身的公匙通过哈希算法生成一个摘要
然后用服务器的私匙来对摘要进行加密 简称数字签名
发送一个包含数字签名和你自己的公匙的东西传送给对方 简称数字证书 
当我得到数字证书的时候将数字证书中的对方公匙通过哈希算法形成消息摘要然后用服务器私匙进行加密
对照接收的数字签名 如果相同则证明没有受到攻击 这样加密的交换了对称加密的公匙 之后就可以进行加密传输了

正式细节
    浏览器发送安全请求
    接收服务器发送的数字证书 包含服务器公匙(这里的服务器公匙已经被ca的私匙加密了)
    浏览器通过CA的列表验证证书，如果有问题就提示风险(这里会进行验证通过ca的公匙来解密服务器公匙，然后验证数字签名)
    浏览器发送随机生成的对称密匙用服务器发来的公匙进行加密
    发送给服务器 服务器将发送来的数据通过服务器私匙进行解密
    双方得到对称密匙进行加密通信。
    注意！！！     
        权威机构的公匙不需要传递，因为权威机构会和操作系统厂商进行合作将自己的公匙直接嵌入在操作系统(浏览器)中
        中间人无法篡改内部的消息，因为中间人没有ca的私匙，用公匙解密篡改之后无法加密回去，这样的话在数字签名的
        验证中如果有被篡改那么就会被发现
        中间人掉包证书也是不行的，因为到验证域名是否和当前域名相同，如果使用了不相同域名的证书在监测的时候也会报错
    
中间人劫持
    我们通过双方的公匙进行加密，互相加密之后传输到各自的位置，然后再通过各自的私匙进行解密得到数据
    中间人截取双方的公匙
    王 李
    王拿到中间人的公匙加密发送数据
    中间人通过自己的私匙进行解密查看数据，通过李的公匙进行加密这段数据(或者自己编造数据)发送给李
    李收到数据然后使用自己的私匙解密查看数据，在通过中间人公匙进行加密回传  
"""

# GET 和 POST的区别
"""
GET 和 HEAD一般被认为是安全方法，所谓的安全方法就是不会进行操作的方法，也就是说使用这两个方法不会产生什么动作
但是这一切都是有web开发者制定的规则，也就意味着随时可以按照开发者的想法修改
GET 用来获取资源
POST 用来传输实体主题
一般来讲GET的额外数据是加在url上的 url的数据只支持ASCll码所以会转义中文之类的
POST的数据是传输在 body中 POST支持标准字符集所以可以传递很多数据

安全
    只是可读的方法是安全的GET POST传输数据所以可能会产生一些更改所以不是很安全
幂等
    一个同样的请求多次的效果是一样的
    不论调用多少次客户端接收的结果都是一样的
"""
# 重定向
"""
HTTP重定向  就是基本的300左右的重定向
DNS重定向
任播寻址
IP MAC 转发
IP地址转发


"""