"""
写点计网的笔记
"""
"""
OSI七层协议:
    应用层：针对特定应用的协议
    表示层：将数据流转换成合适表示方法，比如视频
    会话层：管理连接的创建和关闭
    传输层：进行可靠的数据传输
    网络层：管理地址和路由选择,负责在不同网络之间转发数据包，基于数据包的IP地址，尽力的传输，丢了就丢了
    数据链路层：传输数据帧
    物理层：网线
分层协议的理解:
    分层协议就相当于程序的函数，最终结果分别调用了所有的函数来得到结果，
    每个层次的作用相互独立，当你想修改某一个方面的时候只需要修改其中一层，
    而不需要将整个程序进行大规模改动。
os:
    翻译过来是操作系统

传播方式
    单播 
        比如电话 一对一
    广播
        电视信号  一对多
    多播
        和广播类似，但是要限定接收对象
    任播
        从多台接收对象主机中选择一台合适的进行通信
        
包
    总体的称呼
帧
    数据链路层中包的称呼
数据报
    IP UDP等网络协议上面的包的称呼
段
    TCP数据流的称呼
消息
    应用协议中数据的单位
    
数据包发送流程:
    先确定发送数据，选择合适的协议以TCP为例子
        首先添加TCP首部将包发送下一层
        到达IP层将包加上IP首部，如果这个时候还不清楚目的地址的mac地址，先通过ARP协议分析出MAC地址然后再进行将IP和MAC地址
        发送到以太网，以太网再从包首添加以太网首部，发送数据
        每个首部都要有地址的，以太网首部MAC收发地址 IP首部IP收发地址 TCP首部端口号收发地址 
        
IP协议:
    IP协议是一个面向无连接的服务，为了简化和提速，所以我们在上面使用TCP有链接的服务来对数据进行可靠传输。
    简称IP协议是一个尽力的服务，尽最大的能力进行传输，但是还是会出现各种错误。之所以不在IP协议就将事情全部完成呢
    因为一个协议如果要存在这么多的机制会十分复杂，分离开会简单得多。
    链路层:
            在进行传输的时候，先检查子网掩码查看是不是处于一个路由网络中，如果是的话就不需要通过路由器转发，
            直接通过MAC地址就能进行查找
    网关:
        就是通向互联网的IP地址，使用这个IP来进行网络世界的沟通，得到消息后再从本网关的局域网通过MAC进行传输
    IPV4 32位
    IPV6 128位
    
    DNS
        因为IP地址很难以记住所以使用DNS
    ARP:
        复习一下前面讲arp的知识，作用上来说就是通过IP地址去寻找mac地址。
        然后从实现上来说就是先广播ARP请求分组出去寻找ip对应的mac，然后再单播ARP响应分组回来。
        但是，这里的ARP是解决同一局域网上的主机或路由器的IP地址和硬件地址的映射问题。
        也就是说广播出去的ARP请求分组只有本局域网上的所有主机上运行的ARP进程能收到。
        但是当要找的主机和源主机不在同一局域网上时，源主机得先ARP得到此局域网的网关路由器的mac地址，
        然后由网关从转发表找出下一个该去的路由，这里同时也是使用了ARP来进行获取下一个网关的mac地址，
        然后最后类似的过程找到目标主机的mac,然后进行通信。
        通过发送请求包和接收响应包来得到MAC地址
        先发送一个请求包包含了想要去的主机的IP地址和MAC地址通过链路发送到所有可以发送的主机上，这些主机接收了你发送的ARP包，从中
        解析出其中的IP地址如果和自己的IP地址相同，那么就返回自己的MAC地址发送给源主机
        为了防止多次重复的发送ARP请求，一般都会建立一个ARP缓存表，如果有已经被缓存的MAC地址ARP请求就不需要从新发送ARP包了。
        每次从新执行一次ARP请求都会刷新缓存表
    MAC地址:
        MAC和IP的存在关系
        因为在二层网关中会根据MAC地址转发数据
        而到了路由器第三层中才会根据IP来进行转发
        在同一个网络中不需要IP转发只用网关就行了 
        存在MAC和IP两个地是可以存在筛子作用的，因为接收到
        信息，以太网在判断MAC地址不是本机，也没有下面要传递的地址，直接拒绝接受，如果是往上在匹配本地IP地址往上传递给
        TCP/UDP

tcp udp均采用五个数据来标识源端口号目的端口号源地址目的地址协议号
TCP:
    分时系统:
        多个终端与主机相连接
    分组交换:
        当一个端点向一个目的端点发送数据这样还好专属通道随时可以使用，也可以使用任意时间
        但是如果这个端点是一个路由端点他建立的连接有很多条，还像上面一样就会出现问题，谁也不知道某一次连接要持续多久
        其余的连接如果也要经过这里就会被堵塞，这个时候使用了分组交换。
        将一个大的数据分割成一个个小的数据包发送到了目的地址再一个一个组合到一起
        每次分组的时候都要在包首添加报文首部，标识目的端口源端口序列号之类的信息
        使用了分组交换就可以一直发送数据，按照先入先出队列发送，但是网络数据经常会出现问题，比如路由缓存的数据过多
        造成的分组丢失之类的。
    流协议:
        数据如同水管里的水一样持续流动发送
UDP:
    长度多大就发多大，接收端也就接受多大  
    



   面向连接指的是使用TCP的两个程序必须在可以交换数据之前，先要创建TCP连接
   是面向连接的提供可靠交付，有流量控制 拥塞控制 提供全双工通信面向字节流(将应用层传下的数据成为字节流
   并且把字节流分割成大小不等的数据块)每一条TCP连接都可以说是点对点的连接 
   标志位:
        ACK 确认号 为一的时候认为数据是有效的 建立连接后一般所有的报文段都把ACK置1
        FIN 用来释放连接 当FIN 1 的时候表示报文段发送完毕
        SYN 同步序列号 SYN 1 ACK 0 连接请求报文段 如果对方同意连接返回 SYN 1 ACK 1 
        RST 重置连接
        ISN 初始序列号是一个随机的值 定义是一个
        序列号 相当于本次发送的报文段的第一个字节的编号 这个编号从0开始到2的32次方-1为止，之后从0再次赋值
        确认号 和序列号是一样的一个字段，包含的值是该确认号的发送方希望接受的序列号的值，
               最后被成功接收的数据字节的序列号+1
    TCP的连接由四个元组构成，分别是两个端口和两个IP地址对应的socket编程
    三次握手
    client                                                                                      server
                                    SYN 1 seq x
                发送一个SYN置1的报文段 并且客户端趁机指明自己想要的端口和
                初始系列号ISN(x)x为随机数                       ------>
                
                                SYN 1 ACK1 seq y ack x+1
                <------接收到客户端发来的请求返回响应，服务器发送一个SYN ACK报文段说明接收到请求
                并且发送服务器的初始序列号ISN(y)y为随机数，确认号ack为x+1 
                
                                ACK 1 seq x+1 ack y+1 
                收到服务器传来的同步信息发送ACK确认返回服务器想要的序列号x+1和确认号y+1------>
                
    双方通过一个SYN报文段来交换双方的初始序列号
    三次握手原因，因为防止打开失效连接让服务器打开错误连接 发送一个建立连接的请求可能会超时，
                 超时之后就会客户端会重新发送连接  但是超时连接会重新发送到服务器 
                 这时如果没有三次握手就会打开两个连接 使用了三次握手就会忽略这种无效链接
                    
    四次挥手
    client                                                                              server
                                FIN 1 ACK 1 seq k ack l
                有一方发送完了所有数据准备关闭连接，这个时候发送一个FIN ACK报文段
                (ACK用于确认上一个报文段已经接收完毕)一个自己当前的序列号k和确认号l----->
                
                                ACK 1 seq l ack k+1
                <---------接收方就收到FIN报文段返回一个ACK表示接收到了你的关闭请求然后发送
                序列号l和确认号k+1
                
                                FIN 1 ACK 1 seq l ack k+1
                <----发送FIN ACK关闭连接序列号l确认号k+1
                
                                ACK seq k ack l+1
                发送ACK确认关闭连接序列号为k 确认号为l+1 ------->
                
                client 主动进行关闭发送FIN 1
                客户端接收之后处于半关闭状态
                server能像client发送数据反过来就不行
                server不需要连接的时候发送FIN 1 
                client接收后进入TIME-WAIT阶段等待2MSL(最大报文存活时间)之后释放连接
                server接收到client发来的确认释放连接
                
        当客户端向服务器发送FIN之后服务器进入CLOSE-WAIT阶段方便服务器发送未传输完毕的数据
        传输完毕之后服务器会发送FIN 释放连接
        
        客户端收到服务器的FIN并不会直接关闭会进入2MSL阶段
            为了接受服务器发送的剩余数据 为了确保最后一个报文到达，如果server没收到client发来的
            确认请求那么就会重新发送连接释放报文
            等待一段时间是为了让本链接持续时间内所产生的报文都从网络中消失防止下次连接的时候
            还会有上次的数据。
    LISTEN
        监听程序等待进行连接
    SYN_SENT
        客户端主动发送了一个SYN序列号等待返回确认号
    SYN_RECV
        服务器接受了一个SYN并且返回SYN ACK 等待接受客户端发送的确认号建立连接
    FIN_WAIT1
        应用程序主动发送FIN并且等待返回ACK确认关闭
    FIN_WAIT2
        已接收FIN关闭连接，只能接受数据
    CLOSING
        之前发送了FIN的节点没有收到ACK反而收到了对发送的FIN双方同时想关闭这个连接，这种情况很少
    LAST_ACK
        之前处于CLOSE_WAIT的节点发送了FIN 等待对面发送ACK结果如果得到了就关闭连接释放所有资源     
    CLOSE_WAIT状态
        当服务期接收到客户端传来的FIN的时候就会进入这个状态，进入这个状态的时候用来发送还没发送完的数据给
        客户端，当数据全部发送完毕。服务器就会发送FIN报文段来请关闭连接。
    TIME_WAIT状态
        又被称为2MSL等待状态 MSL最大段生存期，代表报文被丢弃之前在网络中可以存在的最长时间，一般来说最大时间是两分钟
        但是也可以修改
        TIME_WAIT用来确保最后一个确认报文能够到达，如果服务器没有收到客户端传来的确认信息这样服务器就会重传释放连接的
        FIN报文，等待的时间的就是为了这个事情，正好两倍MSL。
        并且通过两倍的最大段生存期来保证本次连接的所有报文都从网络中消失防止下次连接的时候还会出现本次连接的报文
    为什么建立连接是三次握手而结束连接是四次挥手呢:
        因为客户端在LISTEN状态下收到请求建立连接的SYN的时候返回的SYN和ACK都在一个报文中发送，
        而对于结束连接收到对方的FIN的时候只是证明了对面已经
        CLOSE了不会继续发送数据了，但是对方还是可以接受数据的，我方也是可以立即CLOSE但是我方可能没有发送完所有的
        数据，所以可能会再继续发送数据然后再CLOSE所以这样说ACK和FIN一般都是分开发送的。所以结束连接需要四次挥手
        
    TCP重传机制:
        有一个重传队列，你每次发送一个数据的时候就会在重传队列中复制一个，并且重传计时器开始计时，在重传队列中每个数据段
        都是按照剩余重传计时器的剩余时间来进行排列的，方便TCP进行数据的追踪。当收到确认序号ACK的时候这个数据就在重传队列中
        删除，超过计时的时候就会自动重传，数据还在重传队列中不动，重传计时器被重新计时。要是重发还是没有反应，继续重发的时候
        重传计时器的时间长度以指数增长，但是不会无限增长，时间到了到一定长度就会强制关闭连接
        在现实使用的时候发送了四个报文段前两个报文都被接收了，第三个报文丢失了但是第四个报文也接受到了，这个时候
        不会返回接收到第四个报文的确认号，因为第三个报文没被接收，这个时候等待计时器超时会重传第三个报文等待重传被接收
        再返回三四的确认报文
        选择性重传，因为有的时候上面的这种方法不是很智能，所以可以使用SACK来进行选择重传
        必须客户端和服务器同时同意用这个字段才能使用，比如上面的情况返回的确认字段中包含了一个SACK字段说明接收到了。
        (每次接收数据的时候都会返回一个确认字段如果出现了片段三丢失的情况接收到片段四的时候ACK返回的确认号还是片段二的)，
        第四个代码片段但是尚未返回确认号，这个时候在重传队列中就把片段四的SACK置1，当发送重传片段三的时候就不会发送
        片段四了，重传完成后将SACK清除，因为可能会发生一些奇怪的事情导致片段四出现错误，所以需要得到确认号才能明确的说明
        没有问题，如果没有收到那么就会发生重传
    滑动窗口:
        在接收到确认号的时候也同时会发送当前接收程序可用的缓存空间的大小(也就是你可以发送多少字节，
        滑动窗口协议确定你能够同时发送多少TCP数据，当返回的确认信息显示缓存空间不足的时候，滑动窗口就关闭防止溢出。)
        发送方和接收方必须就它们将要为数据流中的字节指定的sequence number达成一致。这一过程称为同步，在TCP连接建立时完成。
        为了简化假设第一个字节sequence number是1，按照上图示例，四类字节如下：
        1. 已发送已确认字节1至31。
        2. 已发送但尚未确认字节32至45。
        3. 未发送而接收方已Ready字节46至51。
        4. 未发送而接收方Not Ready字节52至95
        发送窗口23类的和
        可用窗口3类
    流量控制:
        在双方进行连接的时候接收方会告诉发送方自身能够接受的最大数据量，这样发送方就会按照这个来控制自己发送的的数据长度
        也就是窗口大小，如果接收端的缓冲区已经满了可能会溢出没这样就会再告诉发送端一个更小的值防止浪费资源，
        这个值在报文的首部，是一个可以随时变动的值(缓冲区变小就减小，缓冲区变大就增加)，通过这个来进行TCP流量控制。
    拥塞阻塞机制
        慢开始与拥塞避免:
            设置一个cwnd值每次收到这个确认信息就加倍这个值(这个值为发送报文段的数量)
            因为这个值增长的太快所以设定一个门限值ssthresh 当cwnd值比门限值大的时候就每次只增加一个报文段
            如果出现超时那么令ssthresh的值为cwnd/2重新执行慢开始
        快重传和快恢复
            快重传如果收到三个同样的确认号就重传下一个报文段
            并且执行快恢复ssthresh等于cwnd/2 cwnd等于ssthresh
UDP:
    无连接的服务，尽可能最大交付 没有拥塞控制(对于应用层的报文不拆分只增加一个UDP的首部)支持一对一
    一对多 多对一等交互通信
    DNS 使用udp 一个数据包就能解决了不需要太过于复杂
"""