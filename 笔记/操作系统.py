# 操作系统
# 1. 内存管理
# 2. 驱动管理
# 3. 进程线程协程
# 4. 文件系统

# 内存
"""
32位电脑 4G
DOS 内存是程序自己控制
Windows 统一的内存空间 4G
虚拟存储器
1. CPU n核心  ALU cpu寄存器
2. 每个核心 L1 L2 cache miss
3. 整个CPu L3 3M
4. 内存 很大很大8G
5. 硬盘
6. 网络传输

虚拟存储器，统一的内存模型
一个程序 4G 内存+硬盘
电脑4G
a 1G -> 内存中  页表
b 1G -> 内存中  页表

c 3G -> 把a存储，把c load进来

a => page fault => page load => 正常运行
"""
# 局部性原理 分时系统 页表
"""
局部性原理:
    时间局部性:
        如果程序中的一条指令被执行那么不久之后可能会再次执行，一段数据被访问那么不久之后可能会再次被访问
    空间局部性:
        一旦程序访问了一个存储单元那么和它相邻的存储单元也会被访问
分时系统:
    将每个程序都分配一个短小的时间片，时间片使用结束之后就轮转程序，因为每个时间片都非常的小所以程序轮转的就会很快
    让我们以为程序是在同时运行的，其实不然。
页表:
    页表是虚拟内存(硬盘)和物理内存之间的映射，用来确定该块数据应该对应那一块内存地址
    一个页表有页号和页框号 页框号用来对应物理储存的地址
    虚拟地址有页号和偏移量 虚拟地址的页号用来对应页表的页号 偏移量不知道干啥的
"""
# 驱动
"""
2. 驱动
    ps/2 usb bluetooth
    flopy disk
    linux: 统一成文件 read write seek
"""
# 文件系统
"""
3. 文件系统
    数组
    [meta元信息 对应的文件位置（偏移量） 对应的文件大小]
    格式化： 会把所有信息抹掉
    快速格式化：meta清空
    文件的储存是索引的，有一个磁盘块被当成索引块，这个索引块记录了一些权限信息然后是文件具体存在的磁盘块，如果文件
    过大，需要的磁盘块一个索引块记录不清的话就可以使用一个间接块跳到下一个索引块继续记录文件
    每个目录都需要索引来记录整个文件的储存空间
    删除一个文件的步骤
        在目录中删除文件
        释放inode索引块到节点池
        将不需要的磁盘块释放到空闲的磁盘块池

    所有的问价你，存在同一个file
    /main/main.py -> file load -> execute
"""
# 进程线程
"""
1. 进程 pid 时间片
2. 多线程
3. 线程和进程
进程同步 控制多个进程按照一定顺序执行
进程通信 进程之间传输信息
    方法 管道 命名管道 消息队列 信号量 socket 共享储存
    进程是资源分配的基本单位
        进程拥有资源 线程访问资源
    线程是独立调度的基本单位
    进程间通信 pipe file socket
    线程通信 n线程来说 我都可以看到进程中的全局数据

    对于一个进程来说，你持有了一个页表
    对于同一个进程内的线程，你共享同一张页表

进程调度算法
    在不同系统中进程调度算法是不同的所以按照不同的系统来进行区分
    批处理系统
        没有太多的用户操作，主要需要处理的就是吞吐量和周转时间(就是从提交到终止的时间)
        处理方法 先来先服务  短作业优先  最短剩余时间优先
    交互式系统  
        交互式系统有很多的用户操作 主要的目标是快速响应
        时间片轮转算法
            就是将所有的就绪进程按照先来先服务的情况排成一队，然后给队首的进程一个时间片运行，等时间片结束之后将队首的
            进程放进队尾。  这个算法的主要问题就是和时间片的大小有关 太小进程切换的太频繁太大不能保证实时性。
        优先级调度
            将每个进程都设定一个优先级，按照不同的优先级进行顺序选择
        多级反馈队列
            
4. 多线程同步问题

    数组 支持add
    1. 把数组size + 1
    2. 把add的这个数字放在 data[size]

    两个线程 同时add
    1. A线程 走了1
    2. B线程 也走了1
    3. A存了数据 data[size] = xxx
    4. B也存了数据 data[size] = xxx

    核心在于
    你的操作被拆分
    解决方案呢？
    1. atomic swap_and_cmp
    2. 加锁，mutex，信号量，读写锁，自旋锁。
        自旋锁就是给这个数据加个锁拿到了的修改变量为true 然后进行操作，其余进程在运行的时候也对锁进行抢夺
        看到这个锁被别人拿到之后，就在cpu里面一直抢，直到时间片结束或者正在使用的进程将数据修改完成，释放这把锁。
        这样的基础自旋锁没有设计重入效果，如果有程序递归的进行就完蛋了，所以改进的话需要记录是哪个程序得到了锁
        然后这个程序如果重复得到的话就计数+1 同样释放的时候就计数-1，当值为0的时候才是真的释放
            抢不到的话就回去队列等待锁释放再继续抢
        信号量 生产者消费者
        设定队列空闲值 x
        full值 y
        while：
            如果empty的值小于等于0那么说明队列已满生产者等待
            如果大于0那么开始运行，给数据加锁防止出现错误
            释放锁
            增加full值传给消费者告诉他队列更新了
        while
            如果full值为0那么说明队列里没有新的数据 消费者等待
            不为0加锁防止和生产者产生冲突 进行操作
            释放锁
            通知生产者有空位了
            
            

    加锁以后，我对这个资源有所有权，
    在我所有操作没有结束前，
    其他操作这个数据的人，就要等待

    数组 支持add
    1. 加锁
    2. 把数组size + 1
    3. 把add的这个数字放在 data[size]
    4. 解锁

    两个线程 同时add
    1. A线程 走了1
    2. B线程 也走了1
    3. A 2
    4. A 3
    5. A 解锁
    4. b走2，3，4

    同步会有问题？产生了死锁
    哲学家进餐

    1. 为什么死锁？获取资源的顺序不一样
    对于底下哲学家 先1后2
    对于上面哲学家 先2后1

    所有的哲学家都是先1后2
    1. 调整最后一个人的顺序
    2. 如果我那不到右手，那我左手的也不要

    线程安全的交换数据的函数
    swap(a,b)
    id(a) id(b)
    a.lock()
    b.lock()
    exchange(a.data, b.data)
    a.unlock()
    b.unlock()

    swap(a,b) ------ swap(b,a)
"""
# 并发并行 同步异步 阻塞非阻塞
"""
    并发 并行
    不管你多少个线程，只要你系统能处理多个事情，就是并发的
    并行 这些事情都是在同一时间执行的 多线程 多进程
    并发指的是在同一段时间能够运行多个程序
    并行指的是在同一段时间内能够运行多个指令

    同步异步 事件发生与否，需要你自己去检查
             事件的发生与否，这个是别人通知给你的
    阻塞非阻塞
            阻塞 等
            不等，就是非阻塞
"""

# 补码的概念
"""

    假设是4位的系统
    1000    0   1000    0     
    1001    1   1001    -1
    1010    2   1010    -2
    1011    3   1011    -3
    1100    4   1100    -4
    1101    5   1101    -5
    1110    6   1110    -6
    1111    7   1111    -7
    理论上是这样来表示数字的，但是实际上内部是使用补码来表示数字的，正数的补码就是自己本身
    负数的补码是除了标志位取反+1 但是相比正数要多了个1000来表示-8
    这样就可以了理解很多东西内部的数据取值了比如4位系统的话[2的3次方-1，-2的3次方]
    1111 -1
    1110 -2
    1101 -3
    1100 -4
    1011 -5
    1010 -6
    1001 -7
    1000 -8
    一开始使用反码来进行负数的保存，但是出现的问题是和原码的整数同时会产生两个0，这个时候用补码来进一步的优化去掉属于负数
    的0 补码就是除了标志位取反加1 计算机内部是使用补码来表示数字的(正数的补码就是原来的数) -1的补码和1的补码相加是0
    这里因为取消了负数0所以负数的值要比正数的最大值多1
    
位运算
    x & 1 判断最后一位的奇偶性  x % 2 判断最后一位是不是1
    x = x & (x-1) 清零最低位的1
    x & -x 得到最低位的1
"""

# 递归
"""
递归就是一次一次的调用本身直到最后运行到基线条件的时候一个个返回直到得到自身的值
在运行的时候会不停的堆栈，一层一层的向下累计栈帧，直到程序最后到达基线条件从程序出口返回值，并且一层一层的返回到
顶部出口，但是递归是不太好的，有的时候递归太多会爆栈
尾递归
在返回的时候修改一下 
    原版本
        return n * next(n-1)
    尾递归
        return next(n-1, yy * x)
    增加一个参数这样的话就可以进行尾递归优化，由于当前函数的计算已经结束了，不需要再等待参数回传，所以说
    可以重复使用一个栈帧
    
"""
# 编译 解释 JIT
"""
编译？ 一个代码编译成另外一种代码，编译到机器码，目标代码就是机器码
解释？ c语言是统一的，那我用c语言写出一个虚拟机，这个机器是可以部署到任何机器的
     python语言，语言逐条转换成对应的虚拟机指令
JIT just in time compiler 把最热的代码替换成编译到机器码
"""

# 动态VS静态
"""
a = ''
a = 1
a = True

a = ''
a = 'hello'
a = 'test'
"""
# 强类型弱类型
"""
1 + '1'
1 + 1
"""
# GC
"""
有GC 无GC garbage collection
new delete // malloc free c, c++
有gc: java golang python ruby scala js
new
1. mark & sweep concurrent mark sweep
标记清除算法 扫一遍数据
2. ref counting
python 一般使用这个 引用计数 看有多少东西使用这个有三个人使用它我们不清除他，当没有人使用的时候我们就将它清除
"""
# 大小端:
"""
大小端:

    先存储最高位的是大端，先存储最小位的是小端
"""



