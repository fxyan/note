""""
事务
满足ACLD特性的一组操作
A原子性
    事务被分割成不可分割的最小单元 要么全部成功要么全部失败
C一致性
    事务在执行前后都保持一致性，在一致性状态下所有事务对一个数据的读取结果是相同的
L隔离性
    一个事务在最终提交之前对其余事务是不可见的
D持久性
    一旦事务被提交那么就会永远保存在数据库中
使用关系
    持久性是为了防止数据库崩溃
    事务成功必须满足一致性
        并发的时候要满足原子性和隔离性
        非并发的时候满足原子性就可以

防止挂掉需要日志，在进行操作之前先进行日志操作，预防断电之类的情况，可以根据日志进行回滚

并发一致性问题
在并发的时候隔离性很难满足所以出现的一系列问题
解决办法加锁来保持隔离性
    丢失修改
        T1 T2 都对一个数据进行修改
        T1 先修改 T2 后修改 这样的话T2覆盖了T1的修改
    读脏数据
        T1修改了一个数据 T2读取了这个数据
        随后T1撤回了修改 T2读取的数据就是脏数据
    不可重复读:
        T2读取了一个数据但是中途T1修改了数据导致T2两次读取的数据不同
    幻影读
        T1读取一个范围中的数据 之后T2在这个范围插入数据
        T1再次读取这个数据那么和第一次读取的结果不同

加锁
读写锁
    排它锁 写锁
    共享锁 读锁
    使用方法
        一个事务对一个数据家了写锁那么这个事务就可以对数据进行读取和更新的操作，加锁期间别的事务
        不能给他加锁
        一个事务对一个数据加了读锁那么这个事物就可以读取这个数据，但是不能修改，加锁期间别的事务
        也可以对该数据加读锁 但是不能加写锁
意向锁

范式
所有范式都是一级一级来的满足第三范式的第一二范式肯定也满足
1FN
    1NF的定义为：符合1NF的关系中的每个属性都不可再分
    每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大
    假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），
    那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常
    假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了
    （一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常
    假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常
2FN
    先了解一些基本概念
    函数依赖
        在一张表中属性x确定 那么必定能确定属性y称为y函数依赖于x x->y
    完全函数依赖
        比如需要(学号 课程) -> 分数 这种情况单独得到学号或者课程都不能够确定分数 这样就是完全函数依赖
    部分函数依赖
        (学号 学生姓名) -> 学生宿舍 这种情况得到学号或者学生姓名都能得到 学生宿舍 这样是部分函数依赖
    传递函数依赖
        你能通过A得到B又能通过B得到C 那么就是C传递函数依赖于A
    非主属性
        不在码中的属性
    码
        表中的一个属性或者属性组k 除了k以外的所有属性组都完全依赖与它那么这个属性被称为候选码
        (当k确定的情况除了k之外的所有属性也都随之确定了 这样的情况k就是码)一般选择一个码作为主码

    第二范式的主要目的就是为了消除非主属性与码之间的部分函数依赖 将表进一步分割成多个表
    使得每个非主属性都与码存在完全函数依赖
3FN
    消除了非主属性对于码的传递函数依赖
    不知道怎么说

"""