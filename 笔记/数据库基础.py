""""
关系型数据库的操作，一般都是基于集合的操作，每次都操纵一个集合，复杂的嵌套的就是基于一个集合
多次对这个集合的数据进行操作。
一般建立表的时候使用的是表名( 属性名  属性类型 , ...... , ....... )的建立方式
关系就是一个笛卡尔积的有特定含义的子集

要求每一列都是相同的数据类型

主键:
    一个表的主键，能够表示不同的列，要求每一行的数据都是不相同的
外键:
    一个表的某一列是另外一个表的主键，这样的列称为外键，外键是两个表之间关联的必须属性
    外键可以为空，但是如果外键出现了的话就必须是它所关联的下一个表中的主键的值，如果出现了下一个表中的主键
    以外的值那么是不允许的。

其实数据库语言其实满足内部的代数运算规律而产生的
关系代数操作，并 差 交 必须满足并相容性:
    来自两个表
    a time char(3) name int(4)
    b ctime char(3) yname int(4)
    a 和 b 的属性数目相同，并且来自相同的域(个人理解，就是都是同一种数值类型)
并操作
    其实和数学操作没什么区别啦
    将两个关系元组合并成一个关系元组，去掉重复元组
差操作
    举一个简单的例子
    a 为学过计算机系统的学生
    b 为学过数据库的学生
    a 差 b 是只学过计算机系统的学生
    b 差 a 是只学过数据库的学生
    a 并 b 是学过计算机系统和数据库的学生
除操作
    R/S S必须是R的子集，而且除完之后的结果每一个都可以和S进行组合成为R中的一组数据 例子
    R           S           T         其中和S没关系的数都被排除了
    a  b  c     a  b        c
    1  2  3     1  2        3
    4  5  6     4  5        6
    0  9  8


笛卡尔积
    就是两个表的全部数据相乘
    a time  name
      1    2
      3    4
    b ctime yname
      5     6
      7     8
    笛卡尔积
   c  time  name ctime yname
        1    2     5     6
        1    2     7     8
        3    4     5     6
        3    4     7     8

选择和投影:
    选择是在已有的关系中选择出新的行来组成新的关系
    投影是在已有的关系中选择出新的列来组成新的关系
    投影之后 对于关系来说，是一个集合如果有重复出现的元素应该去除

等值连接
      当你要查找的数据处于多个表之中，那么你需要将这些表连接起来，首先将这些表的连接的笛卡尔积算出来，然后再按照
    选择和投影来进行筛选数据
更名操作
      条件特殊的情况下可以考虑连接自己，那么需要将自己进行一个重命名的操作
自然连接
      两个表要建立连接，一个表的一列对应另一个表的一列完全相同(也可以是部分相同)那么就是自然连接
    A   B   C                       B   R   T           自然连接之后的表    A   B   C   R   T
    1   2   3                       2   4   7                               1   2   3   4   7
    2   1   4                       1   3   8                               2   1   4   3   8
    4   9   3                       3   0   4           最后一列B的值不相等所以没有连接，重复列B合并成1行

元组集合域
    元组简称是一行
    集合就是列
    域是字段类型

数据库完整性
    广义完整性
        语义完整性   并发控制    安全控制    DB故障恢复
    狭义完整性
        语义完整性
    完整性约束条件

触发器
    触发器就是在进行一个操作的 前/后 进行的一个约束防止表的完整性别破坏，产生不良影响
    写一个简单的例子
        当对teacher表的元组进行更新之后使其工资只能升不能降
        create trigger teacher_chgsal before update of salary
            on teacher
            referencing new x, old y
            for each row when(x.salary < y.salary)
            begin
            (报错信息)
            end
        某一学生要更改其主码s的值的时候要求该同学的已选课记录s也自动随其改变
        create trigger upds after update of s on student
        referencing old oldi, new newi
        for each row
            begin
                update sc set s = newi.s where s = old.s
            end
        当删除某一个同学s时，该同学的所有选课有都要删除
        create trigger dels after delete on student
        referencing old oldi
        for each row
        begin
            delete sc where s=olds;
        end

数据库的安全性
    保证数据库安全的一种策略免受非法非授权用户的使用泄露更改和破坏
    安全机制
        存取控制，也可以说是访问控制，通过权限来增加用户数据安全性
        强制分类，通过对数据和用户的分类，使不同的类别的用户能够访问不同的数据
        推断控制机制，通过历史信息推断出用户不该知道的数据
        数据加密，加密解密来进行数据的保护

虽然上面的运算一般都是先建立了笛卡尔积，然后从中选择，但是在实际操作中DBMS会直接从中进行操作，不需要生成笛卡尔积

事务
满足ACLD特性的一组操作
数据库事务的四种特性
    原子性:
        事务的操作，要么全部执行，要么全部不执行，不能出现只执行一半的操作
    一致性:
        对于事物的操作要符合数据库的约束，如果出现了不符合约束的情况就把他回滚
    隔离性:
        对于一个事务而言，在他没有执行完之前对于其余的事务是透明的，别人无法干扰你的操作
    持久性:
        就是当事务提交或者回滚之后，能够保证数据可以持久的被保存住，一般都是在硬盘中记录日志来进行数据的持久化，
        当发生故障的时候通过日志来进行数据的恢复

防止挂掉需要日志，在进行操作之前先进行日志操作，预防断电之类的情况，可以根据日志进行回滚

并发一致性问题
在并发的时候隔离性很难满足所以出现的一系列问题
解决办法加锁来保持隔离性
    丢失修改
        T1 T2 都对一个数据进行修改
        T1 先修改 T2 后修改 这样的话T2覆盖了T1的修改
    读脏数据
        T1修改了一个数据 T2读取了这个数据
        随后T1撤回了修改 T2读取的数据就是脏数据
    不可重复读:
        T2读取了一个数据但是中途T1修改了数据导致T2两次读取的数据不同
    幻影读
        T1读取一个范围中的数据 之后T2在这个范围插入数据
        T1再次读取这个数据那么和第一次读取的结果不同

加锁
读写锁
    排它锁 写锁
    共享锁 读锁
    使用方法
        一个事务对一个数据家了写锁那么这个事务就可以对数据进行读取和更新的操作，加锁期间别的事务
        不能给他加锁
        一个事务对一个数据加了读锁那么这个事物就可以读取这个数据，但是不能修改，加锁期间别的事务
        也可以对该数据加读锁 但是不能加写锁
意向锁

建模
    联系种类
        一对一
            一个实体A的实例只能和一个实体B的实例发生联系，反过来说一个实体B的实例只能和一个实体A的实例产生联系
            一个经理只能有一个商店，一个商店只有一个经理
        一对多
            一个实体A的实例能和多个实体B的实例发生联系，反过来说实体B的实例只能和一个实体A的实例发生联系
            一个画家可以画很多画，每幅画只能有一个画家
            一对多的联系可以通过外键来进行保存
        多对多
            实体A的实例可以和多个实体B的实例发生联系，反过来说实体B的实例可以和多个实体A的实例发生联系
            一门课程可以被多个学生选择，一个学生也可以选学多门课程
            一般都是将两个属性脱离出去组建一个新的表进行保存
        外键是联系多个表之间的纽带
    部分参与联系
        实例可以完全不参与联系最小基数为0
    完全参与联系
        实例至少有一个参与联系最小基数为1
        这两种联系方式主要是为了处理空值，解决多个情况

    简单写一个建模流程
        寻找可以被管理的实例
        找到每个实例的属性
        找出每个实例的主键(确定实例的方法主要就是首先找到主键，再看是不是有一些特有的属性如果有就是没有就不是)
        分析不同实例之间的联系
        判断联系方式 多对多一对一等等

        确定主键之后，如果有一个值可以和他单独对应那么就在一个表中
        如果有多个值和其对应那么应该新建一个表
    从属实体
        需要继承主实体的一部分属性添加到表中，简称外键

    防止冲突
        属性冲突 类型取值范围不同
            学校编码不同
        取值单位冲突
            重量单位有的是千克有的是镑
        结构冲突
            职工在某种应用中是实体，在另外的东西中抽象成属性
        命名冲突
            同名异义 不同意义的对象有不同的名字
            异名同义 不同名字的对象有相同意义


    范式
    所有范式都是一级一级来的满足第三范式的第一二范式肯定也满足
    1FN
        1NF的定义为：符合1NF的关系中的每个属性都不可再分，通俗点说就是没列都是一个数据，和见过的所有表一样，不能一列
        表示城市和住址，只能是城市和住址其中之一。

        解决方式
            如果不满足第一范式，直接将数据拆开就行了拆成原子的

        每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大
        假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），
        那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常
        假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了
        （一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常
        假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常
    2FN
        先了解一些基本概念
        函数依赖
            在一张表中属性x确定 那么必定能确定属性y称为y函数依赖于x x->y
            年龄家庭住址依赖于学生姓名
        完全函数依赖
            比如需要(学号 课程) -> 分数 这种情况单独得到学号或者课程都不能够确定分数 这样就是完全函数依赖
        部分函数依赖
            (学号 学生姓名) -> 学生宿舍 这种情况得到学号或者学生姓名都能得到 学生宿舍 这样是部分函数依赖
            一般来讲部分函数依赖是要消除的部分
        传递函数依赖
            你能通过A得到B又能通过B得到C 那么就是C传递函数依赖于A
            一般也是要消除的部分
        非主属性
            不在码中的属性
        码
            表中的一个属性或者属性组k 除了k以外的所有属性组都完全依赖与它那么这个属性被称为候选码
            (当k确定的情况除了k之外的所有属性也都随之确定了 这样的情况k就是码)一般选择一个码作为主码

        第二范式的主要目的就是为了消除非主属性与码之间的部分函数依赖 将表进一步分割成多个表
        使得每个非主属性都与码存在完全函数依赖
        例子
            R(S, SN, SD, CN, G)
            S学号 SN学生姓名 SD班级 CN课程 G成绩
            函数依赖 SN->S SD->S G->S CN
            由上面的函数依赖可以看出，候选键就是 S CN，这里的非主属性不满足第二范式，存在部分函数依赖 比如S SN
            解决方案 分解上面的表
            {S, SN, SD}     {S, GN, G}
            分成了两个表这样就满足了第二范式
    3FN
        消除了非主属性对于码的传递函数依赖
        例子
            R(A, B, C, D, E, F, G)
            函数依赖(A->B, A->C, C->D, C->E, E->FG)
            这个表是不符合第三范式的需要进行拆分
            {A, B, C} {C, D, E} {E,F,G}
    BCNF
        消除主属性对码的部分函数依赖

数据库的物理储存
    数据库在磁盘上储存
        定长记录
            数据的一条记录长度是固定的，比如char之类的数据类型，通过这些数据类型的长度来从一条记录中分隔出每条属性
        变长记录
            当有的数据类型是变长的时候varchar，数据的大小会自动变化，这个时候使用一个指针来进行标记结尾的值，来分隔每条属性
        记录是否跨块存储
            因为有的时候一个磁盘块在存储了几个记录之后剩余空间无法存储下一个纪录了，这个时候就有两种选择
            1.使用剩余空间在末尾添加指针指向储存该记录剩余部分的下一个次磁盘块，缺点就是这样无法并行的读取数据
            2.不使用剩余空间，从一个新的磁盘块中继续记录，这样可以并行的读取数据而不会出现问题，但是剩余空间会被浪费，所以
                需要按照不同的情况来进行判断
    数据库表所占磁盘块的分配方法
        连续分配    分配到连续的磁盘块中
        链接分配    分配到不连续的磁盘块中每个磁盘块之间按照指针连接
        按簇分配    簇是若干个连续的磁盘块，每个簇之间用指针连接
        索引分配    使用一个索引磁盘块进行记录，索引块中存放指向实际数据的指针
    文件记录方法
        无序记录
            1.每次有新的记录到的时候就插入到文件末尾，有记录删除的话，不直接删除记录，在被删除的记录上加一个标记声明被删除
                这样做是防止记录被删除的时候每次都向前移动数据，这样会有大量的数据IO，缺点就是这样被删除的数据空间没有被使用
                造成了空间浪费
            2.大体上和上面是一样的，区别有新来的文件插入的时候插入到被标记删除的文件的位置中，虽然也会因为被删除文件的大小和
                插入文件的大小不同导致有空间浪费，但是相对的还是要好得多。
        排序记录
            按照顺序储存每条数据，主键就是排序码，这样的话对于按照顺序进行的搜索就会有很多优秀的方法(比如二分)来加快检索效率
            但是对于非按照顺序的检索就不会有很多速度上的加快
            对于顺序储存来说增加记录如果在原来的列表上增加，是十分危险的因为会进行大量的数据移动，一般都会分出两个文件，
            主文件是已经排好序的数据库表，溢出文件是后面增加的数据，对于溢出文件很大的情况检索效率就会降的很低，所以需要
            周期性的对数据库表进行重组(这个就是DBA的事情了)
        散列排序
            通过哈希来计算一个值，文件就储存在计算得知的下标那里，哈希可能会出现哈希碰撞，所以每个哈希值都有一个桶，用来存储
            定量的数据，得到哈希值之后从中再顺序的遍历这个桶，来找到文件。
            桶满了的话解决方案，准备一些多余的空桶当有桶满了的话就连接到这些桶中。
        聚簇文件
            将具有相同或者相似值的数据存放于连续的磁盘簇块中
索引
    索引一般由两列组成，一列是索引列(一般由数据库表的一列数据组成)一列是指针列(用来指向具体的行的数据的储存地址)
    索引是一个辅助存储结构，它的存在不会影响主储存的结构
    可以对不同的属性或者属性组合建立索引，可以建立多个索引文件索引字段的值可以是任何一个属性的值或者多个属性的值的组合
    索引文件很小，可以直接全部装载到内存中，快速定位之后在读取大文件
    更新操作必须同时更新主文件和索引文件，不这样的话索引就会出错
    创建索引
        在数据库中如果你对一个表定义了主键，那么DBMS就会自动创建主索引，利用主索引进行快速定位，然后进行后续操作
        索引可以被用户创建和撤销
        当索引被创建的时候DBMS都会自动维护所有的索引保持一致性，比如新增数据之后会更新索引
        当表被删除之后，所有的相关索引也会被删除
        例子
            -- 在student表中创建一个基于Sname的索引
            CREATE INDEX idxSname ON student(Sname);
            -- 在student表中创建一个基于Sname和Sclass的索引
            CREATE INDEX idxSnamecl ON student(Sname,Sclass);
            -- 撤销索引
            ALTER TABLE student
            DROP INDEX idxSname;
    稀疏索引
        对于主文件的部分记录有索引的对应项，搜索方式  先搜索稀疏索引如果不在索引上的值，那么找到一个相邻的小于目标值的最大
        项，然后再按顺序从表内找到对应项。这种索引的数据一定是按照顺序排序的不然无法检索
    稠密索引
        对于主文件的所有不同记录都有索引的对应项，对于主键来说这样就好了因为主键不重复。
        对于非主键的稠密索引，出现重复数据的时候一种是将数据按照顺序储存，然后找到第一个相同的值然后顺序向下找。
        第二种就是索引中可以有重复的值每个值对应各自的数据
        第三种如果要求索引中不能有重复的数据而且数据不是按照顺序排序的，可以对应一个中间层，索引指向中间层，不重复的数据
        中间层只有一个，重复数据的索引指向对应数据中间层，里面的包含了所有重复数据并且是按照顺序排序的，然后再顺序查找
    主索引
        每个储存块有一个索引项，索引项的值是这个存储块的第一条数据，指针直线对应的存储块。主索引是按照索引字段排序的文件
        通常建在有序主文件的基于主码的排序字段上，主索引是稀疏索引
        可以利用主索引重新组织结构，但是辅助索引不行
    辅助索引
        辅助索引可能是对于非排序字段上的每一个不同值都有一个索引项，索引项的值是该字段的不同值索引项指针指向存储块或者是
        记录本身，对于有重复项的情况，采用链表模式来保存包含该字段值的记录的位置。比如上面稠密索引的第三种
        本身是稠密索引
    聚簇索引
        索引中临近的数据在储存块中也是临近存储的 举个例子 如果20000个元组聚簇索引 储存在1000个储存块中，读取的话就是
        1000次IO,但是如果是非聚簇的可能20000条元组储存在20000个储存块中，这样最坏情况就可能出现20000次I/O
        如果有一个聚簇索引该列数据不同的值的个数是100，那么如果你想找该列数据的值为0的时候，那么通过索引只需要
        1000/100 = 10  10次IO就可以找到了。     相反如果是非聚簇索引最坏情况 就需要 20000/100 = 200次IO差距很大
        不过如果不同值为20000，那么无论是聚簇索引还是非聚簇索引都是一次IO就能找到
        在表中非主码的排序字段的值是非唯一的，这种是聚簇字段，聚簇索引也是在这这种字段上建立的
        聚簇索引一般对于相同值之记录一次，如果有多个相同值指针指向第一个值的存储块，
        一个主文件只能有一个聚簇索引，但是可以有多个非聚簇索引，
        主索引一般是聚簇索引但是索引项的数量不是主键的非不同值的数量，而是存储块的数量
        主索引和聚簇索引可以确定存储位置。
    非聚簇索引
        索引中临近的数据在存储块中不一定是临近存储的
    倒排索引
        普通的索引是 doc{word1， word2....}通过文章告诉你内部有什么单词
        倒排索引是 word{doc1， doc2......}通过单词来寻找文章
    多级索引
        B+树
            [p1, k1, p2, k2,.....p(n-1), k(n-1), p(n)]    内部有n-1的索引项(p, k)和额外的一个指针
            p是指针指向索引块或数据块或数据块中记录的指针     k索引字段值
            非叶子节点的指针指向索引块       叶子结点的指针指向磁盘块或者文件的记录位置
            索引字段在叶子节点中是按顺序排序的
            最低一级的叶子结点就是一个完整的索引，上面的引导都是对于叶子结点的索引而建立的索引
            每个索引块的利用率在50% 到 100% 之间
        B树和B+树之间的区别
            B树的索引字段值只出现一次或者在叶节点或者在非叶节点，
            指向主文件的指针不仅仅出现在叶子结点，非叶子节点也会出现
            所有节点才能覆盖所有键值的索引
        B+树的优点
            每个节点能够保存的索引项相比B树要多
        在插入数据删除数据的时候B/B+数都会进行分裂与合并来保持数据结构的特点
    索引文件组织方式
        排序索引文件  按照排序规律的索引
        散列索引文件  按照散列桶的索引

数据库查询算法
    迭代器算法
        待定
    一趟扫描
        磁盘上的关系能够完整的装到内存中就是一趟扫描就行了
    这里涉及了一个从磁盘上读到内存中的算法(我还没有学操作系统，等学完了或许会有更加深刻的认识)
        如果是聚簇关系的话一般有两中扫描算法，一种直接将数据扫描读进内存中复杂度为n，另一种在读数据的同时也将数据进行排序
        复杂度3n，索引扫描n，排序索引扫描 n到3n之间  这里的n是存储块的数目
        非聚簇     扫描tn(元组数)因为不是相邻的存储所以可能会存储元组数个存储块扫描也就需要tn了,排序扫描tn+2n
    具体每个SQL语句的实现复杂度
        DISTINCT 去重
            每次从磁盘读取数据的时候先和内存中的已处理元组进行比较，如果重复的就去掉，如果不重复就输出，如果是新元组就输出并且
            保存到内存中。内存中应该建立一些数据结构来进行储存处理过的元组，优秀的数据结构(B+树，哈希表....)可以减少程序运行时间
            这是一趟扫描的话硬性需求是数据不能大于内存的大小，时间复杂度n
        GROUP BY 分组查询
            内部其实和上面的去重没啥区别，需要在内存中保留所有的分组信息和分组上面的聚集函数，其余很相似
            这是一趟扫描的话硬性需求是数据不能大于内存的大小，时间复杂度n
    两趟扫描算法
        两趟算法和多趟算法主要的原因就是内存不能装载进所有的数据然而想要去重或者怎样的话，必须要该元组与其余所有元组对比
        才能实现，这样就产生了对于两趟算法或者多趟算法的需求
        第一趟
            先划分子集，因为无法直接将所有数据装进内存，所以将数据划分成不同的子集，每个子集有不同的特点(散列值相等或有序...)
        第二趟
            对第一趟已经处理完的子集进行操作，比如多子集的归并，相同散列值的操作
        一般来说两种两趟算法
        基于排序的两趟算法
            TPMMS
            总体思路就是将数据分成子集，子集数量小于内存数量，然后进行排序，如果内存太小就进行多趟排序
        基于散列的两趟算法

查询优化
    主要就是乘积操作会出现十分大的数据量，先进行选择操作然后进行乘积操作就可以减少很多不必要的乘积操作下面是三个基本的
    优化方法
        语义优化
            利用模型的语言及完整性进行优化
        语法优化
            逻辑优化，运用语法改变操作的运行顺序
            尽可能最后去做乘积运算，改变次序之后结果应该是等价的
            选择和投影串在一起进行这样一遍扫描数据库就能得到结果
                SELECT *  FROM A1, A2, A3, A4
                这里的FROM的先后顺序决定了那个先读到内存中，一般选择较小的表在前
        执行优化
            物理优化存取路径和执行算法的选择与执行次序优化
            物理优化一般都是靠不同的数据结构来处理的
    优化总体思路
        例如SQL语句
            去掉无关的表，去掉无关的属性，转换成更合适的SQL语言
"""