"""
c语言中一个变量如果不进行赋值 例如  int a;  这样的话变量是没有被初始化的，所以变量的值是这个变量的内存地址，进行计算的时候
很有可能会出现些奇怪的数字(有的编译器可能也会直接报错，毕竟编译型语言具体还是看编译器)，所以如果定义了变量一定要初始化

1234是int类型 long类型的数据后面加上 l或L 当整数数值太大的话会默认成为long
无常量字符用 u U 结尾
有小数点没有f结尾的是 double      有f结尾的是float
字符常量在c语言中会转成ascll码其实和数字是相同的，进行运算的时候也是用数字，但是为了明确和方便就写成了这样
""字符串在c语言中其实是代表了一个用结束符'\0'作为结尾的包含字母x的字符数组
关于 '' 和 "" 的区别
    'x' 其实代表了一个x转换成ascll的整数
    "x" 代表了一个包含\0结尾的一个字符数组
枚举类型 如果内部没有定义值的话默认第一个为 0 后面依次为 1 2 3 4
如果内部定义了值那么后面的没有定义的值将会依着前一个定义的值依次增加  枚举的变量名都是不相同的
    enum month { JAN=1, FEB, MAR, APR, MAY, JUM }
    FEB 2   MAR 3
const限定值表示不能够被修改
不同的数值是有长度范围的，如果将较长的数据类型转换成较小的数据类型，那么就会出现数值的丢失int和float的类型转换


scanf("%d", &price); 从交互输入读取一个整数保存到price变量中(具体读取整数还是什么和 % 后面的值有关)记住前面要加上&
在scanf的 "" 中间的数据都是他需要你输入的里面的字符和空格你都不能不输入

const int AMOUNT = 100  定义一个常量用于以后的计算
const 是一个修饰符，这个修饰符用来放在 int char....之类的前面，表明这个常量是一个不允许被修改的常量(这个常量要先被赋值)

整数进行运算的时候也是整数，如果想出现小数点的话应该用浮点型
float double        %f 浮点数  double 输出用 %f  scanf用 %lf
%o表示八进制     %x 十六进制     %c表示字符  %s表示字符串 %%表示本百分号身
%3.0f表示待打印的float长度为3       %6.1f表示待打印的float长度为6并且包含一个小数(小数长度包含在这6位中)
%.2f表示长度随意但是需要有两位小数         %f就是普通按照字符串打印
符号变量
    #define  名字 文本    个人认为就是定义了一个常量定义在main函数之前，这个常量可以是任何东西，而且不需要声明类型

在c语言这里是没有python那种简单的语法糖的
a, b = b, a     是不行的            c = a;  a = b;  b = c;      进行数值交换
遇到 a += 12 + 6  其实是等于  a = a + 12 + 6   先运行等号后面的运算然后再进行前面的
与&& 或|| 非！ 优先级 ！> && > ||   这里有个小陷阱对于&&左边是False右边的值就不进行运算了  对于||来说左边是true右边也不算了
所以如果右边的表达式是一个更改数值之类的操作，那么就会出现问题，因为没有被计算
三目运算符 ? :

数组
    类型 变量名称[元素数量]

定义函数之前要有函数声明
    int pose(int a, int b)
    放在第一个函数开始之前，由于c函数是从头到尾进行的程序，所以说如果你在主函数后面定义了函数，那么主函数需要通过前面的
    这一行来确定你的调用是不是正确。编译器在进行检查的时候不会检查参数的名称，只会检查参数的类型
    在c语言中，如果你在前面没有一个明确的定义，那么你就会编译器就会猜测你的函数是怎么样的(具体的猜测方法取决于你的编译器类型)
    例如 minx() 编译器就会猜测这个是一个int类型的函数
    所以推荐是每次的声明都要十分准确
    例子
        void pose()
        main{
            pose(a, b) # 这个时候你的编译器会猜测你的函数的两个值是什么类型的，因为你没有明确定义，也有的编译器会报错
        }
        void pose(double a, double b){
                # 这里出现了错误，因为编译器猜测你上面的是int类型的而你下面是double类型的，这样就出错了
        }
    c语言不接受函数嵌套
变量的作用域
    变量一般只作用于大括号内部，出了大括号变量就无效了，这点和python天差地别
    在大括号外部的变量可以在内部被调用，但是内部的变量出了大括号就会消失，然后内部如果定义了和外部重名的变量，那么内部的变量
    会覆盖外部的变量。
    int a = 5;
    int b = 6;
    if(a < b){
        int i = 10;
    }
    printf("%d", i);  # 这样会报错，显示变量i没有被定义

二维数组
    int a[][5] = {
        {1, 2, 3, 4, 5},
        {1, 2, 3, 4, 5},
    };
    定义二维数组可以像上面那样定义，但是一定要标注出列的数量，行数可以省略
    int a[10] = {
        [0] = 1, [2] = 3, 6
    }
    这样定义的时候表示将0 2 3位置的数组的值设置为1 3 6 其余补0
    sizeof(a)/sizeof(a[0])可以得出数组长度      sizeof(参数) 表示这个参数在内存中占用多少字节
    数组不能直接赋值给另外一个数组，需要遍历才行
    当你用函数传入一个数组的时候需要同时传入数组的长度，不然没办法做计算，因为在新的函数内部无法进行长度的计算

指针
    之前scanf 的 & 符号表示获取变量的地址，它的操作对象一定是变量
    如果想printf输出的话 %p 是用来输出地址的
    例如
    int i = 0;
    printf("%d", (int)&i) // 这里是对 &i 取地址的一个强制类型转换成 int
    printf("%p", &i);
    在32位架构下可能会相等(具体还是要取决于不同的编译器)，但是在64位架构下是不相等的

    int *p      //这里p是一个指针 指针就是一个保存地址的变量
    指针就是这样的东西，前面的函数传递的值都是值的传递不会影响被传递的数，而指针变量拿到了该变量的内存地址的值，对这个指针变量
    进行操作就相当于对原变量进行操作。(这里涉及了c语言的模型，c语言的变量直接储存在内存地址中，可能python也是相同，但是
    python优化了这里的使用，使得可以不必太在意这里细节)


"""
EVENT_READ = (1 << 0)
EVENT_WRITE = (1 << 1)
events = 2
print(EVENT_READ, EVENT_WRITE)
print(bin(~(EVENT_READ | EVENT_WRITE)))

